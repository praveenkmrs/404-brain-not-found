'User Story 1: Customers can create and manage shopping lists, and stash the current cart for later

1) Design Outline (with trade-offs)
- Proposed approach
  - Alternative A (Chosen): Add a new ShoppingList aggregate with its own entity, repository, DTOs, service, and controller. Keep CartService mostly unchanged; implement bulk cart operations inside ShoppingListService using CartRepository to minimize changes. Add one new public method to CartService (clearCart) to support “move” stash and to prepare for Story 2.
    - Why: Additive change; isolates list logic; minimal risk to existing cart flows; simplifies rollout and testing.
  - Alternative B: Extend CartService heavily to handle lists and stash logic internally.
    - Trade-off: Tighter coupling, larger changes, higher risk to existing cart behavior.
- Complexity/risks and mitigations
  - Partial transfer failures (out of stock/inactive): Build a TransferToCartResponse with failedItems reasons. Mitigation: batch-fetch products to avoid N+1 and evaluate availability before writing.
  - Name uniqueness per user: Add unique compound index (userId, name) and check existsByUserIdAndName before creation/rename. Handle duplicate name with 409 Conflict.
  - Security and ownership: All list fetches must be scoped by both listId and userId. Mitigation: repository methods findByIdAndUserId, deleteByIdAndUserId. Controller validates user ownership each time.
- Backward compatibility strategy
  - Additive endpoints (/api/lists/**, POST /api/cart/stash). No changes to existing /api/cart endpoints. Cart merge semantics remain unchanged.
- Design decision (record)
  - Create ShoppingList domain mirroring CartItem structures to ease conversions. ShoppingListService coordinates between ProductRepository for snapshots, CartService/CartRepository for stash/transfer operations, ensuring minimal changes to existing cart flows.

2) Step-by-Step Implementation Plan (JUNIOR-FRIENDLY CHECKLIST)

2.1 Pre-work
- [ ] Create branch
  - git checkout -b feature/shopping-lists-and-stash
- [ ] Sync, build, run tests locally
  - mvn -q -DskipTests=false clean test
  - mvn spring-boot:run (ensure MongoDB is running; default is localhost:27017 per application.properties)

2.2 Code Changes (file-by-file)

A) New Entities

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/entity/ShoppingListItem.java
- Change summary: New entity representing an item saved to a shopping list, mirroring CartItem fields for easy conversion.
- New file:
```java
package pk.ai.shopping_cart.entity;

import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Shopping list item representing a saved product snapshot
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ShoppingListItem {
    private String productId;
    private String productSku;
    private String productName;
    private BigDecimal unitPrice; // snapshot at time of save
    private String currency;
    private Integer quantity;
    private String productImageUrl;
    private LocalDateTime addedAt;
    private LocalDateTime updatedAt;

    public void updateQuantity(int newQty) {
        this.quantity = newQty;
        this.updatedAt = LocalDateTime.now();
    }
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/entity/ShoppingList.java
- Change summary: New aggregate for shopping lists with unique (userId, name) index, plus helpers similar to Cart.
- New file:
```java
package pk.ai.shopping_cart.entity;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDateTime;
import java.util.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Document(collection = "shopping_lists")
@CompoundIndex(name = "uid_name_unique", def = "{\'userId\':1, \'name\':1}", unique = true)
public class ShoppingList {
    @Id
    private String id;

    @Indexed
    private String userId;

    @Indexed
    private String name;

    @Builder.Default
    private List<ShoppingListItem> items = new ArrayList<>();

    private ShoppingListStatus status;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public enum ShoppingListStatus {
        ACTIVE,
        ARCHIVED
    }

    public Optional<ShoppingListItem> findItemByProductId(String productId) {
        return items.stream().filter(i -> i.getProductId().equals(productId)).findFirst();
    }

    public void addOrIncreaseItem(ShoppingListItem newItem) {
        Optional<ShoppingListItem> existing = findItemByProductId(newItem.getProductId());
        if (existing.isPresent()) {
            ShoppingListItem item = existing.get();
            item.updateQuantity(item.getQuantity() + newItem.getQuantity());
        } else {
            newItem.setAddedAt(LocalDateTime.now());
            newItem.setUpdatedAt(LocalDateTime.now());
            items.add(newItem);
        }
        this.updatedAt = LocalDateTime.now();
    }

    public boolean updateItemQuantity(String productId, int quantity) {
        Optional<ShoppingListItem> existing = findItemByProductId(productId);
        if (existing.isEmpty()) return false;
        if (quantity <= 0) {
            return removeItem(productId);
        } else {
            existing.get().updateQuantity(quantity);
            this.updatedAt = LocalDateTime.now();
            return true;
        }
    }

    public boolean removeItem(String productId) {
        boolean removed = items.removeIf(i -> i.getProductId().equals(productId));
        if (removed) this.updatedAt = LocalDateTime.now();
        return removed;
    }

    public int getTotalItems() {
        return items.stream().mapToInt(ShoppingListItem::getQuantity).sum();
    }

    public boolean isEmpty() {
        return items.isEmpty();
    }
}
```

B) New Repository

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/repository/ShoppingListRepository.java
- Change summary: Repository with user-scoped operations and pagination.
- New file:
```java
package pk.ai.shopping_cart.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;
import pk.ai.shopping_cart.entity.ShoppingList;

import java.util.Optional;

@Repository
public interface ShoppingListRepository extends MongoRepository<ShoppingList, String> {
    Page<ShoppingList> findByUserId(String userId, Pageable pageable);
    Optional<ShoppingList> findByIdAndUserId(String id, String userId);
    Optional<ShoppingList> findByUserIdAndName(String userId, String name);
    boolean existsByUserIdAndName(String userId, String name);
    void deleteByIdAndUserId(String id, String userId);
}
```

C) New DTOs

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/CreateShoppingListRequest.java
```java
package pk.ai.shopping_cart.dto.list;

import jakarta.validation.constraints.NotBlank;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CreateShoppingListRequest {
    @NotBlank(message = "List name is required")
    private String name;
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/UpdateShoppingListRequest.java
```java
package pk.ai.shopping_cart.dto.list;

import jakarta.validation.constraints.NotBlank;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdateShoppingListRequest {
    @NotBlank(message = "List name is required")
    private String name;
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/AddToShoppingListRequest.java
```java
package pk.ai.shopping_cart.dto.list;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AddToShoppingListRequest {
    @NotBlank(message = "Product ID is required")
    private String productId;

    @NotNull(message = "Quantity is required")
    @Positive(message = "Quantity must be positive")
    private Integer quantity;
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/UpdateShoppingListItemRequest.java
```java
package pk.ai.shopping_cart.dto.list;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdateShoppingListItemRequest {
    @NotBlank(message = "Product ID is required")
    private String productId;

    @NotNull(message = "Quantity is required")
    @Positive(message = "Quantity must be positive")
    private Integer quantity;
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/ShoppingListItemResponse.java
```java
package pk.ai.shopping_cart.dto.list;

import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ShoppingListItemResponse {
    private String productId;
    private String productSku;
    private String productName;
    private String productImageUrl;
    private BigDecimal unitPrice;
    private String currency;
    private Integer quantity;
    private LocalDateTime addedAt;
    private LocalDateTime updatedAt;
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/ShoppingListResponse.java
```java
package pk.ai.shopping_cart.dto.list;

import lombok.*;

import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ShoppingListResponse {
    private String id;
    private String userId;
    private String name;
    private List<ShoppingListItemResponse> items;
    private Integer totalItems;
    private String status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private boolean empty;
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/StashCartRequest.java
```java
package pk.ai.shopping_cart.dto.list;

import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class StashCartRequest {
    private String targetListId;   // optional
    private String newListName;    // optional
    @Builder.Default
    private boolean keepInCart = false; // default false for move
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/StashCartResponse.java
```java
package pk.ai.shopping_cart.dto.list;

import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class StashCartResponse {
    private boolean success;
    private boolean cartWasEmpty;
    private String action; // NONE | COPIED | MOVED
    private ShoppingListResponse list; // may be null if no list created/modified
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/TransferListToCartRequest.java
```java
package pk.ai.shopping_cart.dto.list;

import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TransferListToCartRequest {
    @Builder.Default
    private boolean overwriteQuantities = false;
}
```

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/dto/list/TransferToCartResponse.java
```java
package pk.ai.shopping_cart.dto.list;

import lombok.*;
import pk.ai.shopping_cart.dto.cart.CartResponse;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TransferToCartResponse {
    private CartResponse cart;
    private List<FailedItem> failedItems;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class FailedItem {
        private String productId;
        private String reason; // OUT_OF_STOCK | PRODUCT_INACTIVE | NOT_FOUND
    }
}
```

D) New Service

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/service/ShoppingListService.java
- Change summary: Business logic for list CRUD, item ops, stash cart, and transfer to cart.
- New file:
```java
package pk.ai.shopping_cart.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import pk.ai.shopping_cart.dto.cart.CartResponse;
import pk.ai.shopping_cart.dto.list.*;
import pk.ai.shopping_cart.entity.Cart;
import pk.ai.shopping_cart.entity.CartItem;
import pk.ai.shopping_cart.entity.Product;
import pk.ai.shopping_cart.entity.ShoppingList;
import pk.ai.shopping_cart.entity.ShoppingListItem;
import pk.ai.shopping_cart.repository.CartRepository;
import pk.ai.shopping_cart.repository.ProductRepository;
import pk.ai.shopping_cart.repository.ShoppingListRepository;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class ShoppingListService {
    private final ShoppingListRepository shoppingListRepository;
    private final ProductRepository productRepository;
    private final CartRepository cartRepository;
    private final CartService cartService;

    // Create a new list
    public ShoppingListResponse createList(String userId, String name) {
        log.info("Creating shopping list \'{}\' for user {}", name, userId);
        if (shoppingListRepository.existsByUserIdAndName(userId, name)) {
            throw new org.springframework.web.server.ResponseStatusException(
                    org.springframework.http.HttpStatus.CONFLICT,
                    "A list with this name already exists for the user");
        }
        ShoppingList list = ShoppingList.builder()
                .userId(userId)
                .name(name)
                .status(ShoppingList.ShoppingListStatus.ACTIVE)
                .items(new ArrayList<>())
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();
        list = shoppingListRepository.save(list);
        return toResponse(list);
    }

    // Rename list
    public ShoppingListResponse renameList(String userId, String listId, String newName) {
        ShoppingList list = getListEntity(userId, listId);
        if (!list.getName().equals(newName) && shoppingListRepository.existsByUserIdAndName(userId, newName)) {
            throw new org.springframework.web.server.ResponseStatusException(
                    org.springframework.http.HttpStatus.CONFLICT,
                    "Another list with this name already exists");
        }
        log.info("Renaming shopping list {} to \'{}\' for user {}", listId, newName, userId);
        list.setName(newName);
        list.setUpdatedAt(LocalDateTime.now());
        list = shoppingListRepository.save(list);
        return toResponse(list);
    }

    // Delete list
    public void deleteList(String userId, String listId) {
        ShoppingList list = getListEntity(userId, listId);
        log.info("Deleting shopping list {} for user {}", listId, userId);
        shoppingListRepository.deleteByIdAndUserId(list.getId(), userId);
    }

    // Get list by id
    public ShoppingListResponse getList(String userId, String listId) {
        return toResponse(getListEntity(userId, listId));
    }

    // List all lists (paginated)
    public List<ShoppingListResponse> getLists(String userId, int page, int size, org.springframework.http.HttpHeaders outHeaders) {
        Page<ShoppingList> p = shoppingListRepository.findByUserId(userId, PageRequest.of(page, size));
        outHeaders.add("X-Total-Count", String.valueOf(p.getTotalElements()));
        return p.getContent().stream().map(this::toResponse).collect(Collectors.toList());
    }

    // Add item to list (product must exist; active/stock not required for list)
    public ShoppingListResponse addItem(String userId, String listId, String productId, int quantity) {
        ShoppingList list = getListEntity(userId, listId);
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new org.springframework.web.server.ResponseStatusException(
                        org.springframework.http.HttpStatus.NOT_FOUND,
                        "Product not found: " + productId));

        ShoppingListItem item = ShoppingListItem.builder()
                .productId(product.getId())
                .productSku(product.getSku())
                .productName(product.getName())
                .unitPrice(product.getPrice())  // snapshot
                .currency(product.getCurrency())
                .quantity(quantity)
                .productImageUrl(product.getImageUrl())
                .addedAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();
        list.addOrIncreaseItem(item);
        list = shoppingListRepository.save(list);
        return toResponse(list);
    }

    // Update item quantity
    public ShoppingListResponse updateItem(String userId, String listId, String productId, int quantity) {
        ShoppingList list = getListEntity(userId, listId);
        boolean updated = list.updateItemQuantity(productId, quantity);
        if (!updated) {
            throw new org.springframework.web.server.ResponseStatusException(
                    org.springframework.http.HttpStatus.NOT_FOUND,
                    "Product not found in list: " + productId);
        }
        list = shoppingListRepository.save(list);
        return toResponse(list);
    }

    // Remove item
    public ShoppingListResponse removeItem(String userId, String listId, String productId) {
        ShoppingList list = getListEntity(userId, listId);
        boolean removed = list.removeItem(productId);
        if (!removed) {
            throw new org.springframework.web.server.ResponseStatusException(
                    org.springframework.http.HttpStatus.NOT_FOUND,
                    "Product not found in list: " + productId);
        }
        list = shoppingListRepository.save(list);
        return toResponse(list);
    }

    // Stash current cart into a list (move or copy)
    public StashCartResponse stashCart(String userId, StashCartRequest request) {
        if (request.getTargetListId() != null && request.getNewListName() != null) {
            throw new org.springframework.web.server.ResponseStatusException(
                    org.springframework.http.HttpStatus.BAD_REQUEST,
                    "Provide either targetListId or newListName, not both");
        }
        Cart cart = cartService.getOrCreateCart(userId);
        if (cart.isEmpty()) {
            log.info("Cart is empty for user {}; nothing to stash", userId);
            return StashCartResponse.builder()
                    .success(true)
                    .cartWasEmpty(true)
                    .action("NONE")
                    .list(null)
                    .build();
        }
        ShoppingList target;
        boolean created = false;
        if (request.getTargetListId() != null) {
            target = getListEntity(userId, request.getTargetListId());
        } else {
            String name = Optional.ofNullable(request.getNewListName()).orElse("My List");
            if (shoppingListRepository.existsByUserIdAndName(userId, name)) {
                target = shoppingListRepository.findByUserIdAndName(userId, name).get();
            } else {
                target = ShoppingList.builder()
                        .userId(userId)
                        .name(name)
                        .status(ShoppingList.ShoppingListStatus.ACTIVE)
                        .items(new ArrayList<>())
                        .createdAt(LocalDateTime.now())
                        .updatedAt(LocalDateTime.now())
                        .build();
                created = true;
            }
        }
        // Merge cart items into list
        log.info("Stashing cart into list \'{}\' (created={}) for user {}", target.getName(), created, userId);
        for (CartItem ci : cart.getItems()) {
            ShoppingListItem sli = ShoppingListItem.builder()
                    .productId(ci.getProductId())
                    .productSku(ci.getProductSku())
                    .productName(ci.getProductName())
                    .unitPrice(ci.getUnitPrice())
                    .currency(ci.getCurrency())
                    .quantity(ci.getQuantity())
                    .productImageUrl(ci.getProductImageUrl())
                    .addedAt(LocalDateTime.now())
                    .updatedAt(LocalDateTime.now())
                    .build();
            target.addOrIncreaseItem(sli);
        }
        target = shoppingListRepository.save(target);

        if (!request.isKeepInCart()) {
            cartService.clearCart(userId); // Move semantics
        }

        return StashCartResponse.builder()
                .success(true)
                .cartWasEmpty(false)
                .action(request.isKeepInCart() ? "COPIED" : "MOVED")
                .list(toResponse(target))
                .build();
    }

    // Transfer list into cart (with stock checks and partial failures)
    public TransferToCartResponse transferToCart(String userId, String listId, boolean overwriteQuantities) {
        ShoppingList list = getListEntity(userId, listId);
        if (list.isEmpty()) {
            CartResponse cartResp = cartService.getCart(userId);
            return TransferToCartResponse.builder()
                    .cart(cartResp)
                    .failedItems(Collections.emptyList())
                    .build();
        }
        // Batch fetch products for stock/active checks
        List<String> ids = list.getItems().stream().map(ShoppingListItem::getProductId).distinct().toList();
        Map<String, Product> productsById = new HashMap<>();
        productRepository.findAllById(ids).forEach(p -> productsById.put(p.getId(), p));

        List<TransferToCartResponse.FailedItem> failures = new ArrayList<>();
        Cart cart = cartService.getOrCreateCart(userId);

        for (ShoppingListItem item : list.getItems()) {
            Product p = productsById.get(item.getProductId());
            if (p == null) {
                failures.add(TransferToCartResponse.FailedItem.builder()
                        .productId(item.getProductId()).reason("NOT_FOUND").build());
                continue;
            }
            if (!p.isAvailable()) {
                failures.add(TransferToCartResponse.FailedItem.builder()
                        .productId(item.getProductId()).reason("PRODUCT_INACTIVE").build());
                continue;
            }
            if (!p.hasStock(item.getQuantity())) {
                failures.add(TransferToCartResponse.FailedItem.builder()
                        .productId(item.getProductId()).reason("OUT_OF_STOCK").build());
                continue;
            }

            // Apply to cart with overwrite or merge semantics using current price/currency
            Optional<CartItem> existing = cart.findItemByProductId(p.getId());
            if (existing.isPresent()) {
                int newQty = overwriteQuantities ? item.getQuantity() : existing.get().getQuantity() + item.getQuantity();
                existing.get().updateQuantity(newQty);
                existing.get().setUpdatedAt(LocalDateTime.now());
                // Update snapshot fields to current product state when transferring (price may change)
                existing.get().setUnitPrice(p.getPrice());
                existing.get().setCurrency(p.getCurrency());
                existing.get().setProductName(p.getName());
                existing.get().setProductSku(p.getSku());
                existing.get().setProductImageUrl(p.getImageUrl());
            } else {
                CartItem ci = CartItem.builder()
                        .productId(p.getId())
                        .productSku(p.getSku())
                        .productName(p.getName())
                        .unitPrice(p.getPrice())
                        .currency(p.getCurrency())
                        .quantity(item.getQuantity())
                        .productImageUrl(p.getImageUrl())
                        .addedAt(LocalDateTime.now())
                        .updatedAt(LocalDateTime.now())
                        .build();
                cart.addItem(ci);
            }
        }
        // Extend expiration to be consistent with addToCart activity
        cart.setExpiresAt(LocalDateTime.now().plusDays(7));
        cart = cartRepository.save(cart);

        CartResponse cartResp = cartService.getCart(userId);
        return TransferToCartResponse.builder()
                .cart(cartResp)
                .failedItems(failures)
                .build();
    }

    private ShoppingList getListEntity(String userId, String listId) {
        return shoppingListRepository.findByIdAndUserId(listId, userId)
                .orElseThrow(() -> new org.springframework.web.server.ResponseStatusException(
                        org.springframework.http.HttpStatus.NOT_FOUND, "List not found"));
    }

    private ShoppingListResponse toResponse(ShoppingList list) {
        List<ShoppingListItemResponse> items = list.getItems().stream().map(i -> ShoppingListItemResponse.builder()
                        .productId(i.getProductId())
                        .productSku(i.getProductSku())
                        .productName(i.getProductName())
                        .productImageUrl(i.getProductImageUrl())
                        .unitPrice(i.getUnitPrice())
                        .currency(i.getCurrency())
                        .quantity(i.getQuantity())
                        .addedAt(i.getAddedAt())
                        .updatedAt(i.getUpdatedAt())
                        .build())
                .collect(Collectors.toList());
        return ShoppingListResponse.builder()
                .id(list.getId())
                .userId(list.getUserId())
                .name(list.getName())
                .items(items)
                .totalItems(list.getTotalItems())
                .status(list.getStatus() != null ? list.getStatus().name() : "ACTIVE")
                .createdAt(list.getCreatedAt())
                .updatedAt(list.getUpdatedAt())
                .empty(list.isEmpty())
                .build();
    }
}
```

E) New Controller

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/controller/ShoppingListController.java
- Change summary: REST endpoints for /api/lists and POST /api/cart/stash. Scoped by userId via @RequestParam (consistent with existing pattern). Includes basic OpenAPI annotations.
- New file:
```java
package pk.ai.shopping_cart.controller;

import io.swagger.v3.oas.annotations.Operation;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import pk.ai.shopping_cart.dto.list.*;
import pk.ai.shopping_cart.service.ShoppingListService;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
public class ShoppingListController {

    private final ShoppingListService shoppingListService;

    // ===== Lists CRUD =====

    @Operation(summary = "Create a new shopping list")
    @PostMapping("/lists")
    public ResponseEntity<ShoppingListResponse> createList(
            @RequestParam String userId,
            @Valid @RequestBody CreateShoppingListRequest request) {
        ShoppingListResponse resp = shoppingListService.createList(userId, request.getName());
        return ResponseEntity.status(HttpStatus.CREATED).body(resp);
    }

    @Operation(summary = "Get shopping lists (paginated)")
    @GetMapping("/lists")
    public ResponseEntity<List<ShoppingListResponse>> getLists(
            @RequestParam String userId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        HttpHeaders headers = new HttpHeaders();
        List<ShoppingListResponse> resp = shoppingListService.getLists(userId, page, size, headers);
        return new ResponseEntity<>(resp, headers, HttpStatus.OK);
    }

    @Operation(summary = "Get shopping list by id")
    @GetMapping("/lists/{listId}")
    public ResponseEntity<ShoppingListResponse> getList(
            @RequestParam String userId,
            @PathVariable String listId) {
        return ResponseEntity.ok(shoppingListService.getList(userId, listId));
    }

    @Operation(summary = "Rename shopping list")
    @PutMapping("/lists/{listId}")
    public ResponseEntity<ShoppingListResponse> renameList(
            @RequestParam String userId,
            @PathVariable String listId,
            @Valid @RequestBody UpdateShoppingListRequest request) {
        return ResponseEntity.ok(shoppingListService.renameList(userId, listId, request.getName()));
    }

    @Operation(summary = "Delete shopping list")
    @DeleteMapping("/lists/{listId}")
    public ResponseEntity<Void> deleteList(
            @RequestParam String userId,
            @PathVariable String listId) {
        shoppingListService.deleteList(userId, listId);
        return ResponseEntity.noContent().build();
    }

    // ===== List Items =====

    @Operation(summary = "Add item to list (increase if exists)")
    @PostMapping("/lists/{listId}/items")
    public ResponseEntity<ShoppingListResponse> addItem(
            @RequestParam String userId,
            @PathVariable String listId,
            @Valid @RequestBody AddToShoppingListRequest request) {
        return ResponseEntity.ok(shoppingListService.addItem(userId, listId, request.getProductId(), request.getQuantity()));
    }

    @Operation(summary = "Update item quantity in a list")
    @PutMapping("/lists/{listId}/items")
    public ResponseEntity<ShoppingListResponse> updateItem(
            @RequestParam String userId,
            @PathVariable String listId,
            @Valid @RequestBody UpdateShoppingListItemRequest request) {
        return ResponseEntity.ok(shoppingListService.updateItem(userId, listId, request.getProductId(), request.getQuantity()));
    }

    @Operation(summary = "Remove item from list")
    @DeleteMapping("/lists/{listId}/items/{productId}")
    public ResponseEntity<ShoppingListResponse> removeItem(
            @RequestParam String userId,
            @PathVariable String listId,
            @PathVariable String productId) {
        return ResponseEntity.ok(shoppingListService.removeItem(userId, listId, productId));
    }

    // ===== Stash Cart =====

    @Operation(summary = "Stash current cart into a shopping list (copy or move)")
    @PostMapping("/cart/stash")
    public ResponseEntity<StashCartResponse> stashCart(
            @RequestParam String userId,
            @Valid @RequestBody StashCartRequest request) {
        return ResponseEntity.ok(shoppingListService.stashCart(userId, request));
    }

    // ===== Transfer List to Cart =====

    @Operation(summary = "Transfer list items into active cart")
    @PostMapping("/lists/{listId}/transfer-to-cart")
    public ResponseEntity<TransferToCartResponse> transferToCart(
            @RequestParam String userId,
            @PathVariable String listId,
            @Valid @RequestBody TransferListToCartRequest request) {
        TransferToCartResponse resp = shoppingListService.transferToCart(userId, listId, request.isOverwriteQuantities());
        return ResponseEntity.ok(resp);
    }
}
```

F) Modify CartService to add clearCart support (also used by Story 2)

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/service/CartService.java
- Change summary: Add clearCart(userId) and public helper to access Cart DTO after saving.
- Diff:
```diff
--- a/shopping-cart/src/main/java/pk/ai/shopping_cart/service/CartService.java
+++ b/shopping-cart/src/main/java/pk/ai/shopping_cart/service/CartService.java
@@ -108,6 +108,29 @@ public class CartService {
         return convertToCartResponse(cart);
     }
+    /**
+     * Clear the active cart for user (idempotent)
+     */
+    public CartResponse clearCart(String userId) {
+        log.info("Clearing cart for user {}", userId);
+        Cart cart = getOrCreateCart(userId);
+        // Preserve metadata: id, status ACTIVE, expiresAt unchanged
+        cart.clear();
+        cart.setUpdatedAt(java.time.LocalDateTime.now());
+        cart = cartRepository.save(cart);
+        log.debug("Cleared cart {} for user {}", cart.getId(), userId);
+        return convertToCartResponse(cart);
+    }
```

G) No change to SecurityConfiguration needed; new endpoints are authenticated by default.

H) API Documentation (OpenAPI) will be generated by springdoc from annotations.

2.3 Config & Secrets
- [ ] No new secrets required.
- [ ] Optional feature flag (not implemented in this patch to keep scope tight). If needed later:
  - Property: features.shopping-lists.enabled=true
  - Use @ConditionalOnProperty if we decide to gate controllers/services.

2.4 Data & Migrations
- [ ] Indexes
  - Added @CompoundIndex unique (userId, name) on ShoppingList. Spring Data will ensure this index on startup.
  - Indexed userId and name for filtering.
- [ ] Forward migration
  - No manual script; allow Spring Data to create indexes. For safety on existing envs, verify using Mongo shell:
    - db.shopping_lists.createIndex({userId:1, name:1}, {unique:true, name:"uid_name_unique"})
    - db.shopping_lists.createIndex({userId:1})
- [ ] Rollback
  - Safe to drop the collection or indices if needed:
    - db.shopping_lists.dropIndex("uid_name_unique")
    - db.shopping_lists.drop()

2.5 Feature Flags / Kill Switch
- [ ] None introduced now. If instability observed, we can add a property-gated @ConditionalOnProperty on ShoppingListController and ShoppingListService.

2.6 Observability
- [ ] Logs
  - Info: list create/rename/delete, stash, transfer.
  - Debug: item-level add/update/remove, failure reasons.
  - Sample: "Stashing cart into list \'Party supplies\' (created=true) for user U123"
- [ ] Metrics (Micrometer) – optional improvement later:
  - counter: shopping_list.created
  - counter: shopping_list.stash.operations
  - counter: shopping_list.transfer.operations
  - counter: shopping_list.transfer.failed_items (tag reason)
- [ ] Tracing
  - Span names: ShoppingListService.stashCart, ShoppingListService.transferToCart

2.7 Performance & Resilience
- [ ] Batch product fetch using findAllById for transfer; single cart save at end of transfer reduces writes.
- [ ] Pagination on list retrieval.
- [ ] No retries added; all operations are single-writes to MongoDB.

2.8 Security & Compliance
- [ ] Data classification: product snapshots and list names are non-sensitive; userId is PII.
- [ ] Input validation via @Valid and @NotBlank/@Positive annotations.
- [ ] Authorization: endpoints require auth by default; user ownership enforced by findByIdAndUserId for every list operation and by requiring userId param. Assumption: userId will be sourced from JWT principal in a future story.
- [ ] No secrets logged; no PII beyond userId in INFO logs.

3) Testing Plan (map directly to acceptance criteria)
- Unit tests
  - Class: ShoppingListServiceTest
    - testCreateList_conflictName_returns409
      - GIVEN existing list name; WHEN createList; THEN throw ResponseStatusException 409. [AC-1 conflict]
    - testAddItem_increasesQuantityWhenExists
      - GIVEN list with P qty 2; WHEN addItem P qty 3; THEN total qty 5. [AC-2]
    - testUpdateAndRemoveItem
      - GIVEN list with P qty 3; WHEN update to 1; THEN qty 1; WHEN remove; THEN product absent. [AC-3]
    - testStashCart_moveAndCopy
      - GIVEN cart with items; WHEN stash newListName keepInCart=false; THEN list created, cart cleared. WHEN keepInCart=true; cart unchanged. [AC-4]
    - testStashCart_conflictingParams_badRequest
    - testStashCart_emptyCart_noListCreated
    - testTransferToCart_mergeAndOverwrite
      - GIVEN list items and cart items; WHEN overwrite=false THEN sum; WHEN true THEN replace. [AC-5]
    - testTransferToCart_partialFailures
      - GIVEN inactive/out-of-stock product; THEN failedItems list contains reasons. [AC-5]
  - Class: CartServiceTest
    - clearCart_idempotentAndPreservesMetadata [tie-in with Story 2; also supports stash move]
- Integration tests (@SpringBootTest + Testcontainers Mongo optional if available)
  - ShoppingListControllerIT
    - create/get/paginate lists [AC-6]
    - conflict on rename [AC-6]
    - delete list returns 204 [AC-6]
    - stash endpoint copies/moves [AC-4]
    - transfer-to-cart returns cart and failed items [AC-5]
- Manual/E2E steps included in section 4.

4) Manual Verification Checklist (QA Playbook)
- Seed products
  - POST /api/products/sample
- Create list
  - curl -X POST "http://localhost:8080/api/lists?userId=U1" -H "Content-Type: application/json" -d \'{"name":"Weekly staples"}\'
- Add item to list
  - curl -X POST "http://localhost:8080/api/lists/{listId}/items?userId=U1" -H "Content-Type: application/json" -d \'{"productId":"<PRODUCT_ID>","quantity":3}\'
- Update and remove
  - PUT /api/lists/{listId}/items?userId=U1 body {"productId":"<PRODUCT_ID>","quantity":1}
  - DELETE /api/lists/{listId}/items/<PRODUCT_ID>?userId=U1
- Stash cart (move)
  - Add items to cart via POST /api/cart/items?userId=U1; then:
  - curl -X POST "http://localhost:8080/api/cart/stash?userId=U1" -H "Content-Type: application/json" -d \'{"newListName":"Party supplies","keepInCart":false}\'
- Transfer list to cart
  - curl -X POST "http://localhost:8080/api/lists/{listId}/transfer-to-cart?userId=U1" -H "Content-Type: application/json" -d \'{"overwriteQuantities":false}\'

Expected:
- 409 for duplicate list name
- 400 for both targetListId and newListName
- 200 with action=NONE when cart empty
- TransferToCartResponse.failedItems populated when stock/inactive issues.

5) CI/CD & DevOps
- No pipeline changes required. Unit/integration tests will run with mvn test.
- Ensure MongoDB available in CI or use embedded Mongo/Mock; if not available, mark integration tests to require profile.
- Health checks unaffected.

6) Rollback & Recovery
- Since changes are additive: rollback by deploying previous artifact.
- Data: shopping_lists collection can remain; it’s harmless. Indices do not break older versions.
- If incident occurs, disable usage of new endpoints at API gateway or remove routes.

7) Risks & Mitigations
- Risk: Unauthorized list access via tampered userId param.
  - Mitigation: Move to principal-derived userId soon; server-side scoping via findByIdAndUserId already enforced.
- Risk: Storage growth due to many lists.
  - Mitigation: Later enforce soft limit per user and cleanup policy.
- Risk: Price drift between saved list and current price.
  - Mitigation: We snapshot price in list; but transfer uses current price, which is correct; document behavior.

8) Pull Request Plan
- Title: feat(lists): shopping lists CRUD, stash cart, and transfer-to-cart with partial failures
- Description:
  - Problem: Users cannot save carts or manage lists.
  - Approach: Add ShoppingList entity, endpoints, stash and transfer flows, partial failure handling.
  - Scope: New entities, repo, service, controller; minor CartService addition.
  - Screens/Logs: Include sample curl and responses; screenshots of Swagger UI.
  - Risk: Ownership enforcement relies on userId param.
  - Rollout: Additive; deploy safely. Verify with QA playbook.
  - Checklist: Tests added, indices created, docs updated.
- Reviewers: Backend lead, Security reviewer (ownership), DB reviewer (indices).
- Focus files: ShoppingListService, ShoppingListController, entity/ShoppingList.java, repository/ShoppingListRepository.java, CartService diff.

9) Commit Strategy
- Commit 1: feat(entity): add ShoppingList and ShoppingListItem entities with indexes
- Commit 2: feat(repo): add ShoppingListRepository with user-scoped methods
- Commit 3: feat(dto): add DTOs for lists, stash, and transfer responses
- Commit 4: feat(service): implement ShoppingListService (CRUD, stash, transfer)
- Commit 5: feat(controller): add ShoppingListController endpoints and OpenAPI annotations
- Commit 6: feat(cart): add CartService.clearCart for reuse; wire stash move
- Commit 7: test: add unit tests for ShoppingListService and CartService clearCart

10) Documentation Updates
- README.md
  - New section: Shopping Lists API overview, endpoints, request/response bodies.
- API docs: Automatically available via /swagger-ui.html; ensure annotations are present.
- ADR: ADR-000X ShoppingLists.md
  - Title: Introduce Shopping Lists and Stash/Transfer Flows
  - Summary: Add new aggregate, endpoints, index strategy, and behavior on price snapshots.

11) Definition of Done (checklist)
- [ ] AC-1: Creating list and 409 on duplicate name – covered by ShoppingListServiceTest and controller tests.
- [ ] AC-2: Add/increase items – tests and manual checks via curl.
- [ ] AC-3: Update/remove items – tests.
- [ ] AC-4: Stash cart (copy/move), validation, empty cart – unit + integration tests.
- [ ] AC-5: Transfer to cart with merge/overwrite and partial failures – tests verify failedItems.
- [ ] AC-6: List/rename/delete with pagination – tests verify X-Total-Count and 204 delete.
- [ ] Telemetry and logging added at info/debug.
- [ ] Indices created and validated in Mongo.
- [ ] Security: endpoints authenticated; ownership enforced.
- [ ] No changes to existing cart endpoints’ schemas.

Diagrams (Mermaid)

- Dependency graph
```mermaid
graph TD
  ProductRepository --> ShoppingListService
  CartRepository --> ShoppingListService
  ShoppingListRepository --> ShoppingListService
  ShoppingListService --> ShoppingListController
  CartService --> ShoppingListService
  ShoppingListService -->|uses| dto_list[DTOs: list/*]
  CartService --> CartController
```

- System overview with highlighted modules
```mermaid
flowchart LR
  subgraph API Layer
    ProductController
    CartController
    ShoppingListController:::highlight
  end
  subgraph Service Layer
    ProductService
    CartService
    ShoppingListService:::highlight
  end
  subgraph Persistence
    ProductRepository
    CartRepository
    ShoppingListRepository:::highlight
  end
  ProductController --> ProductService --> ProductRepository
  CartController --> CartService --> CartRepository
  ShoppingListController --> ShoppingListService --> ShoppingListRepository
  ShoppingListService --> ProductRepository
  ShoppingListService --> CartService
classDef highlight fill:#e0ffe0,stroke:#2a7,stroke-width:2px;
```

- Sequence: Transfer list to cart
```mermaid
sequenceDiagram
  participant C as Client
  participant Ctrl as ShoppingListController
  participant S as ShoppingListService
  participant PR as ProductRepository
  participant CS as CartService
  participant CR as CartRepository

  C->>Ctrl: POST /api/lists/{listId}/transfer-to-cart
  Ctrl->>S: transferToCart(userId, listId, overwrite)
  S->>S: getListEntity(userId, listId)
  S->>PR: findAllById(productIds)
  PR-->>S: products
  S->>CS: getOrCreateCart(userId)
  CS-->>S: Cart
  S->>CR: save(updated cart with merged items)
  CR-->>S: Cart
  S->>CS: getCart(userId)
  CS-->>S: CartResponse
  S-->>Ctrl: TransferToCartResponse(cart, failedItems)
  Ctrl-->>C: 200 OK
```

User Story 2: Customers can clear their shopping cart in a single action

1) Design Outline (with trade-offs)
- Proposed approach
  - Add a new endpoint DELETE /api/cart to clear the active cart for a user. Add a new method clearCart(userId) in CartService that reuses existing getOrCreateCart, calls cart.clear(), updates updatedAt, and saves.
- Complexity/risks and mitigations
  - Risk: Clearing another user’s cart if userId param is misused. Mitigation: Short-term require auth and maintain server-side checks; long-term get userId from principal.
- Backward compatibility
  - Additive endpoint, no changes to existing add/update/remove item endpoints.

2) Step-by-Step Implementation Plan (JUNIOR-FRIENDLY CHECKLIST)

2.1 Pre-work
- [ ] Use the same branch: feature/shopping-lists-and-stash
- [ ] Build check: mvn -q clean test

2.2 Code Changes (file-by-file)

A) CartService was updated in User Story 1. No further change needed if the clearCart method is present (diff already added).

B) CartController: add endpoint DELETE /api/cart

- Path: shopping-cart/src/main/java/pk/ai/shopping_cart/controller/CartController.java
- Change summary: New endpoint to clear the cart.
- Diff:
```diff
--- a/shopping-cart/src/main/java/pk/ai/shopping_cart/controller/CartController.java
+++ b/shopping-cart/src/main/java/pk/ai/shopping_cart/controller/CartController.java
@@ -57,4 +57,17 @@ public class CartController {
         CartResponse cart = cartService.removeFromCart(userId, productId);
         return ResponseEntity.ok(cart);
     }
+
+    /**
+     * Clear the active cart (idempotent)
+     */
+    @DeleteMapping
+    public ResponseEntity<CartResponse> clearCart(@RequestParam String userId) {
+        log.info("Clearing cart for user: {}", userId);
+        CartResponse cart = cartService.clearCart(userId);
+        return ResponseEntity.ok(cart);
+    }
 }
```

2.3 Config & Secrets
- [ ] No config changes required. Endpoint is authenticated by default based on SecurityConfiguration.anyRequest().authenticated().

2.4 Data & Migrations
- [ ] No schema changes. Operation clears items array and updates updatedAt.

2.5 Feature Flags / Kill Switch
- [ ] Not needed. This is a simple additive operation.

2.6 Observability
- [ ] Logs
  - Info: "Clearing cart for user {}"
  - Debug: "Cleared cart {} for user {}"
- [ ] Metrics – optional
  - counter: cart.clear.operations

2.7 Performance & Resilience
- [ ] Single document update. O(1) write. Idempotent behavior ensured.

2.8 Security & Compliance
- [ ] Endpoint requires authentication. Ownership: userId param should refer to the authenticated user (to be enforced via principal in follow-up story). No sensitive data in logs.

3) Testing Plan
- Unit tests
  - Class: CartServiceTest
    - testClearCart_removesItemsAndResetsTotals
      - GIVEN a cart with items; WHEN clearCart; THEN items=[], totalItems=0, totalPrice=0; updatedAt updated. [AC-1]
    - testClearCart_idempotent
      - GIVEN empty/non-existent cart; WHEN clearCart; THEN return empty ACTIVE cart. [AC-2]
    - testClearCart_preservesMetadata
      - GIVEN cart id and expiresAt; WHEN clear; THEN id same, status ACTIVE, expiresAt unchanged. [AC-3]
- Controller tests
  - CartControllerTest
    - deleteCart_returns200AndCartResponse
- Authorization (manual or mock)
  - Ensure unauthorized access is blocked by security (401/403 as per configuration).

4) Manual Verification Checklist (QA Playbook)
- Create active cart by adding an item:
  - POST /api/cart/items?userId=U1 body {"productId": "<PRODUCT_ID>", "quantity": 2"}
- Clear cart:
  - curl -X DELETE "http://localhost:8080/api/cart?userId=U1"
  - Expect 200 and items=[], totalItems=0
- Idempotency:
  - Repeat DELETE; expect same 200 with empty cart.

5) CI/CD & DevOps
- No pipeline updates. Ensure controller tests compile.

6) Rollback & Recovery
- Rollback deploy previous version. No data migration needed.

7) Risks & Mitigations
- Risk: Misuse of userId param.
  - Mitigation: Move to principal in a future story; verify SecurityConfiguration and Jwt filter integrate correctly.

8) Pull Request Plan
- Title: feat(cart): add DELETE /api/cart to clear active cart
- Description: Adds CartService.clearCart and controller endpoint. Idempotent. Tests included.
- Review focus: ensure metadata preserved and idempotency.

9) Commit Strategy
- Commit 8: feat(cart): add DELETE /api/cart endpoint; tests for clearCart

10) Documentation Updates
- README: Document DELETE /api/cart endpoint with example.
- Swagger: Ensure endpoint shows up with description.

11) Definition of Done (checklist)
- [ ] AC-1 Clear existing cart – verified via unit and controller tests.
- [ ] AC-2 Idempotent clear on empty cart – unit tests.
- [ ] AC-3 Metadata preserved – unit test validates id and status.
- [ ] Security verified – endpoint requires auth.

Diagrams (Mermaid)

- Dependency graph
```mermaid
graph TD
  CartService --> CartController:::highlight
  CartRepository --> CartService
classDef highlight fill:#e0ffe0,stroke:#2a7,stroke-width:2px;
```

- System overview
```mermaid
flowchart LR
  subgraph API Layer
    CartController:::highlight
  end
  subgraph Service Layer
    CartService:::highlight
  end
  subgraph Persistence
    CartRepository
  end
  CartController --> CartService --> CartRepository
classDef highlight fill:#e0ffe0,stroke:#2a7,stroke-width:2px;
```

- Sequence: Clear cart
```mermaid
sequenceDiagram
  participant C as Client
  participant Ctrl as CartController
  participant S as CartService
  participant R as CartRepository

  C->>Ctrl: DELETE /api/cart?userId=U1
  Ctrl->>S: clearCart(userId)
  S->>S: getOrCreateCart(userId)
  S->>R: save(cart cleared)
  R-->>S: cart
  S-->>Ctrl: CartResponse
  Ctrl-->>C: 200 OK (empty cart)
```

Notes and Assumptions
- We follow existing pattern of passing userId as @RequestParam to keep consistent with current code. In a subsequent story, we should extract userId from the authenticated principal (JwtAuthenticationFilter) and enforce ownership server-side.
- Lists are non-reservations. We only enforce availability at transfer-to-cart time.
- Price snapshots in lists are for display; actual current prices are applied when transferring to cart.

Commands to run
- mvn -q clean test
- mvn spring-boot:run
- Use curl examples in QA Playbook to verify behavior end-to-end.'