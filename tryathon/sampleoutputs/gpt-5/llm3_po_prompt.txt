'User story: 1

1) Story Title  
   - Enable customers to create and manage personal Shopping Lists

2) Story Recap  
   - Today, customers cannot create custom shopping lists to group products they plan to buy later. They want to create named lists (e.g., “Weekly Groceries”, “Birthday Party”) and add/remove products, so they can quickly start an order from a list.

3) Business Context & Rationale  
   - Why: Shopping lists increase convenience and repeat purchases by letting customers pre-plan and quickly reorder commonly needed items.  
   - Who benefits: End users (faster checkout, organization), business (higher retention and conversion), support (fewer “how do I save items?” complaints).

4) Scope of Work  
   - In scope:
     - Introduce a new Shopping List domain model stored in MongoDB.
     - CRUD on shopping lists: create, rename, delete, list user’s lists, fetch a single list.
     - Manage list items: add product, update quantity, remove product, get list details.
     - Default validations: product must exist, quantity > 0.
     - Security: only the list owner can access/modify their lists.
     - Make it easy to later use a shopping list to populate a cart (not implementing the “start order from list” workflow here; see assumptions).
   - Out of scope:
     - Checkout directly from a shopping list (future story).
     - Sharing lists, collaborative editing, public lists.
     - Advanced list templates, reminders, or notifications.

5) Technical Context (for junior devs)  
   - Likely impacted modules:
     - New: entity/ShoppingList.java, repository/ShoppingListRepository.java, dto/shoppinglist/*, controller/ShoppingListController.java, service/ShoppingListService.java.
     - Existing: ProductRepository (to validate product existence), SecurityConfiguration (endpoint access rules).
   - API shape (proposed, consistent with existing routes):
     - POST /api/shopping-lists               -> create a list
     - GET  /api/shopping-lists               -> list all of user’s lists
     - GET  /api/shopping-lists/{listId}      -> get one list with items
     - PUT  /api/shopping-lists/{listId}      -> rename list
     - DELETE /api/shopping-lists/{listId}    -> delete list
     - POST /api/shopping-lists/{listId}/items           -> add item {productId, quantity}
     - PUT  /api/shopping-lists/{listId}/items           -> update item quantity {productId, quantity}
     - DELETE /api/shopping-lists/{listId}/items/{productId} -> remove item
   - Data model (proposed):
     - ShoppingList { id, userId (indexed), name (unique per user), items[], createdAt, updatedAt }
     - ShoppingListItem { productId, productSku, productName, snapshotPrice, currency, quantity, addedAt, updatedAt, productImageUrl }
     - Index: { userId, name } unique to avoid duplicate list names per user; index userId for listing.
   - Security:
     - Reuse existing auth. Current controllers pass userId as a request param; short-term we can align with that pattern; long-term derive from JWT subject once available.
   - Constraints mentioned by product:
     - Maintainability: mirror DTO pattern used in cart/product.
     - Performance & scalability: index userId; paginate if needed (future).
     - Security: enforce ownership checks server-side for every list access.

6) Acceptance Criteria (use Gherkin-style where possible)  
   - GIVEN a logged-in user  
     WHEN they POST /api/shopping-lists with name = “Weekly Groceries”  
     THEN a 201 response returns a ShoppingListResponse with that name, empty items, and metadata.
   - GIVEN a user with an existing list “Weekly Groceries”  
     WHEN they PUT /api/shopping-lists/{listId} to rename to “Groceries This Week”  
     THEN the list name is updated and returned with 200, and updatedAt reflects the change.
   - GIVEN a list owned by user A  
     WHEN user B attempts GET/PUT/DELETE on that list  
     THEN a 403 Forbidden is returned.
   - GIVEN a user’s list  
     WHEN they POST /api/shopping-lists/{listId}/items with {productId, quantity=3} and product exists  
     THEN the product is added (or merged by incrementing quantity if already present) and 200 returns the updated list.
   - GIVEN a user’s list  
     WHEN they POST items with a non-existent productId  
     THEN a 404 Not Found is returned with an error message “Product not found”.
   - GIVEN a user’s list with a product at quantity 5  
     WHEN they PUT /api/shopping-lists/{listId}/items with {productId, quantity=2}  
     THEN the quantity is set to 2 (not incremented) and a 200 is returned.
   - GIVEN a user’s list with a product  
     WHEN they DELETE /api/shopping-lists/{listId}/items/{productId}  
     THEN the item is removed, and the response includes the updated list.
   - GIVEN a logged-in user with multiple lists  
     WHEN they GET /api/shopping-lists  
     THEN a 200 returns only their lists (not other users’), sorted by updatedAt desc (if implemented).

7) Definition of Done (checklist)  
   - Entity, repository, service, controller, and DTOs created and validated.  
   - Ownership and authorization checks implemented; unauthenticated -> 401, unauthorized -> 403.  
   - Unit tests for service logic (CRUD, item add/update/remove, validations).  
   - Integration tests for controller endpoints (happy paths + error cases).  
   - MongoDB indexes created (userId, unique compound userId+name).  
   - API docs exposed via springdoc updated with new endpoints.  
   - Structured logs at INFO for key actions; DEBUG for details; no sensitive data in logs.  
   - Code reviewed, merged, and feature behind a configuration flag if risky.  
   - Basic performance smoke test (lists with >= 100 items) executes within acceptable latency.

8) Assumptions & Open Questions  
   - Assumptions:
     - A list can contain products even if currently out of stock; availability is checked only when moving items to the cart.  
     - List names are unique per user (case-insensitive).  
     - Max 50 lists per user; max 500 items per list (guardrails to prevent abuse).  
     - We keep a price snapshot for display; actual price is re-validated at checkout.
   - Open questions:
     - Should we support sharing lists with other users?  
     - Do we need pagination for lists/items at launch?  
     - Should duplicate products in a list be prevented or merged automatically? (We propose auto-merge.)

9) Dependencies & Risks  
   - Dependencies: ProductRepository for validating product existence; SecurityConfiguration/JWT for auth.  
   - Risks:
     - Name uniqueness race conditions (mitigate via unique index and handle duplicate key errors).  
     - Data growth in lists (mitigate with limits and indexing).  
     - Inconsistent product snapshots vs. current price (mitigate by re-validating at add-to-cart time).


User story: 2

1) Story Title  
   - Allow customers to “Save for Later” (stash) items from their cart

2) Story Recap  
   - Customers can add items to the cart, but there’s no way to temporarily stash items for future orders without deleting them. They need a “Save for Later” action that removes items from the cart and stores them in a personal saved list for future use.

3) Business Context & Rationale  
   - Why: “Save for Later” reduces cart abandonment by letting users defer items without losing them, leading to more future purchases.  
   - Who benefits: Customers (flexibility), business (recover deferred purchases), support (fewer “I lost my cart items” complaints).

4) Scope of Work  
   - In scope:
     - Introduce Save-for-Later behavior that moves items from the active cart into a user-owned container for later retrieval.
     - Integrate with the shopping list domain from Story 1 by using a default list named “Saved for Later” per user.
     - Endpoints to save items from cart to this default list and to move items back to cart.
     - View saved-for-later items via shopping lists APIs.
     - Validations similar to cart operations when moving items back into the cart (availability, stock).
   - Out of scope:
     - Bulk move entire cart to saved list (future enhancement).  
     - Notifications or reminders about saved items.

5) Technical Context (for junior devs)  
   - Impacted modules:
     - CartController/CartService (new operations for save-for-later and move-back-to-cart).  
     - ShoppingListService (to create/find the user’s “Saved for Later” list and add/remove items).  
     - DTOs: create SaveForLaterRequest {productId, quantity, destinationListId optional}, MoveFromListToCartRequest {listId, productId, quantity}.  
   - API shape (proposed, consistent with existing pattern of userId as param):
     - POST /api/cart/items/save-for-later?userId={userId}  
       Body: { productId, quantity, destinationListId? }  
       Behavior: remove quantity from cart; add to specified list or default “Saved for Later”.
     - POST /api/cart/items/move-from-list?userId={userId}  
       Body: { listId, productId, quantity }  
       Behavior: remove from the list; validate product availability and stock; add to cart (merge quantities).
   - Security: only the owner can save or retrieve their items; deny cross-user access.
   - Data considerations:
     - If removing a partial quantity from the cart, reduce item quantity; if zero, remove the item entry.  
     - If adding to the list and item exists, increment quantity; else create new item entry.

6) Acceptance Criteria (use Gherkin-style where possible)  
   - GIVEN a user with an active cart containing product P with quantity 3  
     WHEN they POST /api/cart/items/save-for-later with {productId: P, quantity: 2}  
     THEN the cart’s quantity for P becomes 1 and P is added to the user’s “Saved for Later” list with quantity increased by 2.
   - GIVEN a user whose cart contains product P with quantity 1  
     WHEN they save-for-later {productId: P, quantity: 1}  
     THEN product P is removed from the cart and appears in “Saved for Later” with quantity incremented by 1.
   - GIVEN a user has no “Saved for Later” list yet  
     WHEN they first use save-for-later  
     THEN the system auto-creates a private list named exactly “Saved for Later” and places the item there.
   - GIVEN a user’s saved-for-later list contains product P quantity 5  
     WHEN they POST /api/cart/items/move-from-list with {listId, productId: P, quantity: 3} and product is available and in stock  
     THEN P is removed by 3 from the list (remaining 2) and added/merged into the cart by 3; response returns updated CartResponse.
   - GIVEN a user attempts to move an item back to cart but the product is out of stock or unavailable  
     WHEN they call move-from-list  
     THEN a 409 Conflict (or 400) is returned with a message “Insufficient stock” or “Product not available,” and no changes are made.
   - GIVEN a user tries to save-for-later a product not present in their cart  
     WHEN they call save-for-later  
     THEN a 404 Not Found is returned with message “Product not found in cart”.
   - GIVEN an unauthenticated request  
     WHEN calling either endpoint  
     THEN a 401 Unauthorized is returned.

7) Definition of Done (checklist)  
   - New DTOs created and validated; endpoints implemented with proper status codes and consistent responses.  
   - Ownership checks and authentication enforced.  
   - Unit tests: cart removal/partial removal; list add/merge; error paths (not in cart, invalid quantity).  
   - Integration tests: end-to-end move cart->list and list->cart including availability checks.  
   - Logging: INFO on moves; DEBUG for details (quantities, ids); no sensitive data.  
   - API docs updated; examples added.  
   - Backward compatibility: no breaking changes to existing cart endpoints.  
   - Basic performance validation for carts/lists up to 200 items.

8) Assumptions & Open Questions  
   - Assumptions:
     - Default list name is exactly “Saved for Later” and unique per user.  
     - Quantity in save-for-later must be <= current cart quantity; quantity > cart quantity returns 400.  
     - Using request param userId for now; later we will derive from JWT subject.
   - Open questions:
     - Should we allow specifying a custom destination list for save-for-later by listId? (We proposed optional destinationListId.)  
     - What response shape should save-for-later return? We propose returning updated CartResponse, plus perhaps a header or link to the affected shopping list.

9) Dependencies & Risks  
   - Dependencies: Story 1 (shopping lists) must be delivered first or in parallel to provide the destination container.  
   - Risks:
     - Concurrency: simultaneous updates from multiple devices could cause quantity drift (mitigate by re-reading and saving atomically; consider optimistic concurrency in a future story).  
     - User confusion if same product is both in cart and saved list (we’ll handle by clear separation and accurate quantities).


User story: 3

1) Story Title  
   - Provide a “Clear Cart” action to empty the current shopping cart

2) Story Recap  
   - Customers can add items to their cart but cannot quickly clear all items and start fresh. They need a single action to empty the cart without deleting individual items one by one.

3) Business Context & Rationale  
   - Why: Reduces friction when users want to start over, improving user experience and reducing abandonment from frustration.  
   - Who benefits: End users (efficiency), support (fewer “how do I reset my cart?” issues).

4) Scope of Work  
   - In scope:
     - Add an endpoint to clear all items from the user’s active cart.  
     - Idempotent behavior: clearing an already empty or non-existent active cart returns a success with an empty cart state.  
     - Update cart metadata: updatedAt should reflect the operation; keep status ACTIVE.
   - Out of scope:
     - Deleting the cart record itself.  
     - Affecting saved-for-later lists or shopping lists.

5) Technical Context (for junior devs)  
   - Impacted modules:
     - CartService: add a clearCart(userId) method using Cart.clear().  
     - CartController: expose an endpoint consistent with existing patterns.
   - API shape (proposed to match current style):
     - DELETE /api/cart?userId={userId}  
       Response: 200 with CartResponse representing an empty cart (totalItems=0, isEmpty=true).
   - Current code notes:
     - Cart entity already has clear() and isEmpty() methods.  
     - CartService has getOrCreateCart(userId) we can reuse to ensure idempotence.  
     - SecurityConfiguration requires authentication for “anyRequest()”; continue to enforce auth.

6) Acceptance Criteria (use Gherkin-style where possible)  
   - GIVEN a logged-in user with items in their cart  
     WHEN they DELETE /api/cart?userId={userId}  
     THEN the response is 200 and CartResponse shows items=[], totalItems=0, isEmpty=true, and updatedAt is refreshed.
   - GIVEN a logged-in user with no active cart  
     WHEN they call DELETE /api/cart?userId={userId}  
     THEN a new empty ACTIVE cart is created (or returned) and a 200 CartResponse reflects empty state.
   - GIVEN a logged-in user with an already empty cart  
     WHEN they call DELETE /api/cart?userId={userId} again  
     THEN a 200 is returned and the cart remains empty (idempotent).
   - GIVEN an unauthenticated request  
     WHEN calling DELETE /api/cart  
     THEN a 401 Unauthorized is returned.

7) Definition of Done (checklist)  
   - New controller endpoint and CartService.clearCart implemented and wired.  
   - Unit tests for service clear logic (with items, empty, no cart).  
   - Integration test for endpoint (authz, success, idempotent).  
   - Logs: INFO on clear operation with userId; no sensitive data.  
   - API docs updated with endpoint description and examples.  
   - Code reviewed and merged; no breaking changes to existing cart APIs.

8) Assumptions & Open Questions  
   - Assumptions:
     - Clearing the cart does not affect “Saved for Later” or shopping lists.  
     - Currency and status fields in CartResponse remain consistent (currency “USD” as today).  
     - We continue to accept userId as a request parameter for now.
   - Open questions:
     - Should we return 204 No Content instead of 200 with CartResponse? We propose 200 to match current controller patterns that return CartResponse bodies.

9) Dependencies & Risks  
   - Dependencies: Authentication/authorization as configured in SecurityConfiguration.  
   - Risks:
     - If later we switch to deriving userId from JWT, we must update this endpoint’s signature accordingly (backward compatibility consideration under feature versioning).  
     - Concurrency: clearing while another device adds items may cause race conditions (acceptable for now; future story can add optimistic concurrency or server-side cart sessions).'